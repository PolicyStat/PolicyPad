<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>WYMeditor</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="streaming-client.js"></script>
<script type="text/javascript" src="collab_client.js"></script>
<script type="text/javascript">

function getPadValues(host, port, padName, callback) {
    var url = host + ':' + port + '/' + padName;
    $.get(url, function(data) {
        var clientJson = data.match(/var clientVars = (.*);/)[1];
	log("Retrieved data: " + clientJson);
	var clientVars = JSON.parse(clientJson);
        callback(clientVars);
    });
}

function log(msg)
{
    var changes = $('#changes');
    $('<div></div>').text(msg).appendTo(changes)
}

globalPadId = "";

function btnConnect_onclick()
{
 	var txtPadId = $("#txtPadId");
	globalPadId = txtPadId.val();
	//globalPadId = "eoYmdwUbH2";
	log(globalPadId);
	log("Retrieving initial state...")
	getPadValues("http://kevinwells.homeip.net", 8082, globalPadId, connect_cb);

}

function btnDisconnect_onclick()
{
	socket.disconnect();
}

/*
getCollabClient parameters

==ace2editor==
setProperty(key, val)
setBaseAttributedText(intialText, apool)
setUserChangeNotificationCallback(cb -> function())
prepareUserChangeset() -> {changeset: [string], apool: [?]}
applyChangesToBase(changeset, author, apool)
applyPreparedChangesetToBase()
setAuthorInfo(userId, {bgcolor: cssColor[, fade: [float]])
getUnhandledErrors() -> [{error: [string], time: [time?]]

==serverVars==
{
rev: int,
padId: string,
globalPadId: string,
historicalAuthorData: {[author]: {colorId: [int]}, ...},
initialAttributedText: ?,
apool: ?,
clientIp: string,
useragent: string
}

==initialUserInfo==
{
userId: string,
colorId: int,
?...
}

==[options]==
colorPalette -> {[colorId]: cssColor, ...}


= Callbacks =
	onUserJoin:     	function(userInfo)
	onUserLeave:    	function(userInfo)
	onUpdateUserInfo:	function(userInfo)
	onChannelStateChange:	function(channelState,	moreInfo)
	onClientMessage:	function(payload)
	onInternalAction:	function(string)
	onConnectionTrouble:	function(string)
	onServerMessage:	function(payload)
}

= Useful Methods =
    setOnUserJoin:		function(cb) { callbacks.onUserJoin = cb; },
    setOnUserLeave:		function(cb) { callbacks.onUserLeave = cb; },
    setOnUpdateUserInfo:	function(cb) { callbacks.onUpdateUserInfo = cb; },
    setOnChannelStateChange:	function(cb) { callbacks.onChannelStateChange = cb; },
    setOnClientMessage:		function(cb) { callbacks.onClientMessage = cb; },
    setOnInternalAction:	function(cb) { callbacks.onInternalAction = cb; },
    setOnConnectionTrouble:	function(cb) { callbacks.onConnectionTrouble = cb; },
    setOnServerMessage:		function(cb) { callbacks.onServerMessage = cb; },
    updateUserInfo:		updateUserInfo(userInfo),
    getConnectedUsers:		getConnectedUsers(),
    sendClientMessage:		sendClientMessage(msg),
    getCurrentRevisionNumber:	getCurrentRevisionNumber(),
    getDiagnosticInfo:		getDiagnosticInfo(),
    getMissedChanges:		getMissedChanges(),
    callWhenNotCommitting:	callWhenNotCommitting(func),
    addHistoricalAuthors:	tellAceAboutHistoricalAuthors(hadata)
*/

function setProperty(key, val)
{
    log("Setting property (" + key + "): " + val);
}

function setBaseAttributedText(initialText, apool)
{
    log("setBaseAttributedText(" + initialText + ", " + apool + ")");
}

function setUserChangeNotificationCallback(cb)
{
    log("setUserChangeNotificationCallback(cb)");
}

function prepareUserChangeset()
{
    log("E: prepareUserChangeset()");
    return {};
}

function applyChangesToBase(changeset, author, apool)
{
    log("applyChangesToBase(" + changeset + ", " + author + ", " + apool + ")");
}

function applyPreparedChangesetToBase()
{
    log("applyPreparedChangesetToBase()");
}

function setAuthorInfo(userId, userInfo)
{
    log("setAuthorInfo(" + userId + ", " + userInfi + ")");
}

function getUnhandledErrors()
{
    log("E: getUnhandledErrors());
    return [];
}



 
function onUserJoin(userInfo)
{
    log("onUserJoin(" + userInfo + ")");
}

function onUserLeave(userInfo)
{
    log("onUserLeave(" + userInfo + ")");
}

function onUpdateUserInfo(userInfo)
{
    log("onUpdateUserInfo(" + userInfo + ")");
}

function onChannelStateChange(channelState,	moreInfo)
{
    log("onChannelStateChange(" + channelState + ", " + moreInfo + ")");
}

function onClientMessage(payload)
{
    log("onClientMessage(" + payload + ")");
}

function onInternalAction(str)
{
    log("onInternalAction(" + str + ")");
}

function onConnectionTrouble(str)
{
    log("onConnectionTrouble(" + str + ")");
}

function onServerMessage(payload)
{
    log("onServerMessage(" + payload + ")");
}





function connect_cb(clientVars)
{
    log("Connecting...");
    ace2editor = {  setProperty: setProperty,
                    setBaseAttributedText: setBaseAttributedText,
                    setUserChangeNotificationCallback: setUserChangeNotificationCallback,
                    prepareUserChangeset: prepareUserChangeset,
                    applyChangesToBase: applyChangesToBase,
                    applyPreparedChangesetToBase: applyPreparedChangesetToBase,
                    setAuthorInfo: setAuthorInfo,
                    getUnhandledErrors: getUnhandledErrors};
    serverVars = {};
    initialUserInfo = {};
    options = {};

    client = getCollabClient(ace2editor, serverVars, initialUserInfo, options);

client.setOnUserJoin(onUserJoin);
client.setOnUserLeave(onUserLeave);
client.setOnUpdateUserInfo(onUpdateUserInfo);
client.setOnChannelStateChange(onChannelStateChange);
client.setOnClientMessage(onClientMessage);
client.setOnInternalAction(onInternalAction);
client.setOnConnectionTrouble(onConnectionTrouble);
client.setOnServerMessage(onServerMessage);
    
    


	//rev = 94;
	//userInfo = {"userId": "g.qneusfqoynmuu354", "ip": "192.168.4.1", "colorId": 5, "userAgent": "Firefox3.6.12"};
	//stats = {"screen":"1206,226,1920,1200,1920,1200","ip": "192.168.4.1", "useragent":"Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.12) Gecko/20101027 Ubuntu/10.04 (lucid) Firefox/3.6.12"};
	rev = clientVars.collab_client_vars.rev;
	userInfo = {"userId": clientVars.userId, "ip": clientVars.collab_client_vars.clientIp, "colorId": clientVars.userColor, "userAgent": clientVars.userAgent};
	stats = getStats(clientVars.collab_client_vars);
	
      socket.onmessage = handleMessageFromServer;
      socket.onclosed = handleSocketClosed;
        socket.onopen = function() {
                log("Socket opened, sending CLIENT_READY...");
                //hiccupCount = 0;
                //setChannelState("CONNECTED");
                var msg = { type:"CLIENT_READY", roomType:'padpage',
                            roomName:'padpage/'+globalPadId,
                            data: {
                              lastRev:rev,
                              userInfo:userInfo,
                              stats: stats
                               } };
                // if (oldSocketId) {
                //   msg.data.isReconnectOf = oldSocketId;
                //   msg.data.isCommitPending = (state == "COMMITTING");
                // }
                sendMessage(socket, msg);
                //doDeferredActions();
        };
      socket.onhiccup = handleCometHiccup;
        socket.onlogmessage = log;
        socket.connect();


}

</script>


</head>

<body>
<h1>Testing stuff</h1>
<form>
  Pad Id: <input type="text" id="txtPadId" value="eoYmdwUbH2" /> <br />
  <input type="button" name="btnConnect" value="Connect" onclick="btnConnect_onclick();" />
  <input type="button" name="btnDisconnect" value="Disconnect" onclick="btnDisconnect_onclick();" />
</form>
<div id="changes"></div>

</body>
</html>
